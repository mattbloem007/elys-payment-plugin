{"id":"XrxB","dependencies":[{"name":"/Users/gabriel/Documents/paymentelys/package.json","includedInParent":true,"mtime":1630498634517},{"name":"/Users/gabriel/Documents/paymentelys/node_modules/secp256k1/package.json","includedInParent":true,"mtime":1629877553686}],"generated":{"js":"const e={IMPOSSIBLE_CASE:\"Impossible case. Please create issue.\",TWEAK_ADD:\"The tweak was out of range or the resulted private key is invalid\",TWEAK_MUL:\"The tweak was out of range or equal to zero\",CONTEXT_RANDOMIZE_UNKNOW:\"Unknow error on context randomization\",SECKEY_INVALID:\"Private Key is invalid\",PUBKEY_PARSE:\"Public Key could not be parsed\",PUBKEY_SERIALIZE:\"Public Key serialization error\",PUBKEY_COMBINE:\"The sum of the public keys is not valid\",SIG_PARSE:\"Signature could not be parsed\",SIGN:\"The nonce generation function failed, or the private key was invalid\",RECOVER:\"Public key could not be recover\",ECDH:\"Scalar was invalid (zero or overflow)\"};function r(e,r){if(!e)throw new Error(r)}function t(e,t,o){if(r(t instanceof Uint8Array,`Expected ${e} to be an Uint8Array`),void 0!==o)if(Array.isArray(o)){const a=`Expected ${e} to be an Uint8Array with length [${o.join(\", \")}]`;r(o.includes(t.length),a)}else{const a=`Expected ${e} to be an Uint8Array with length ${o}`;r(t.length===o,a)}}function o(e){r(\"Boolean\"===n(e),\"Expected compressed to be a Boolean\")}function a(e=(e=>new Uint8Array(e)),r){return\"function\"==typeof e&&(e=e(r)),t(\"output\",e,r),e}function n(e){return Object.prototype.toString.call(e).slice(8,-1)}module.exports=(i=>({contextRandomize(o){switch(r(null===o||o instanceof Uint8Array,\"Expected seed to be an Uint8Array or null\"),null!==o&&t(\"seed\",o,32),i.contextRandomize(o)){case 1:throw new Error(e.CONTEXT_RANDOMIZE_UNKNOW)}},privateKeyVerify:e=>(t(\"private key\",e,32),0===i.privateKeyVerify(e)),privateKeyNegate(r){switch(t(\"private key\",r,32),i.privateKeyNegate(r)){case 0:return r;case 1:throw new Error(e.IMPOSSIBLE_CASE)}},privateKeyTweakAdd(r,o){switch(t(\"private key\",r,32),t(\"tweak\",o,32),i.privateKeyTweakAdd(r,o)){case 0:return r;case 1:throw new Error(e.TWEAK_ADD)}},privateKeyTweakMul(r,o){switch(t(\"private key\",r,32),t(\"tweak\",o,32),i.privateKeyTweakMul(r,o)){case 0:return r;case 1:throw new Error(e.TWEAK_MUL)}},publicKeyVerify:e=>(t(\"public key\",e,[33,65]),0===i.publicKeyVerify(e)),publicKeyCreate(r,n=!0,c){switch(t(\"private key\",r,32),o(n),c=a(c,n?33:65),i.publicKeyCreate(c,r)){case 0:return c;case 1:throw new Error(e.SECKEY_INVALID);case 2:throw new Error(e.PUBKEY_SERIALIZE)}},publicKeyConvert(r,n=!0,c){switch(t(\"public key\",r,[33,65]),o(n),c=a(c,n?33:65),i.publicKeyConvert(c,r)){case 0:return c;case 1:throw new Error(e.PUBKEY_PARSE);case 2:throw new Error(e.PUBKEY_SERIALIZE)}},publicKeyNegate(r,n=!0,c){switch(t(\"public key\",r,[33,65]),o(n),c=a(c,n?33:65),i.publicKeyNegate(c,r)){case 0:return c;case 1:throw new Error(e.PUBKEY_PARSE);case 2:throw new Error(e.IMPOSSIBLE_CASE);case 3:throw new Error(e.PUBKEY_SERIALIZE)}},publicKeyCombine(n,c=!0,s){r(Array.isArray(n),\"Expected public keys to be an Array\"),r(n.length>0,\"Expected public keys array will have more than zero items\");for(const e of n)t(\"public key\",e,[33,65]);switch(o(c),s=a(s,c?33:65),i.publicKeyCombine(s,n)){case 0:return s;case 1:throw new Error(e.PUBKEY_PARSE);case 2:throw new Error(e.PUBKEY_COMBINE);case 3:throw new Error(e.PUBKEY_SERIALIZE)}},publicKeyTweakAdd(r,n,c=!0,s){switch(t(\"public key\",r,[33,65]),t(\"tweak\",n,32),o(c),s=a(s,c?33:65),i.publicKeyTweakAdd(s,r,n)){case 0:return s;case 1:throw new Error(e.PUBKEY_PARSE);case 2:throw new Error(e.TWEAK_ADD)}},publicKeyTweakMul(r,n,c=!0,s){switch(t(\"public key\",r,[33,65]),t(\"tweak\",n,32),o(c),s=a(s,c?33:65),i.publicKeyTweakMul(s,r,n)){case 0:return s;case 1:throw new Error(e.PUBKEY_PARSE);case 2:throw new Error(e.TWEAK_MUL)}},signatureNormalize(r){switch(t(\"signature\",r,64),i.signatureNormalize(r)){case 0:return r;case 1:throw new Error(e.SIG_PARSE)}},signatureExport(r,o){t(\"signature\",r,64);const n={output:o=a(o,72),outputlen:72};switch(i.signatureExport(n,r)){case 0:return o.slice(0,n.outputlen);case 1:throw new Error(e.SIG_PARSE);case 2:throw new Error(e.IMPOSSIBLE_CASE)}},signatureImport(r,o){switch(t(\"signature\",r),o=a(o,64),i.signatureImport(o,r)){case 0:return o;case 1:throw new Error(e.SIG_PARSE);case 2:throw new Error(e.IMPOSSIBLE_CASE)}},ecdsaSign(o,c,s={},E){t(\"message\",o,32),t(\"private key\",c,32),r(\"Object\"===n(s),\"Expected options to be an Object\"),void 0!==s.data&&t(\"options.data\",s.data),void 0!==s.noncefn&&r(\"Function\"===n(s.noncefn),\"Expected options.noncefn to be a Function\");const u={signature:E=a(E,64),recid:null};switch(i.ecdsaSign(u,o,c,s.data,s.noncefn)){case 0:return u;case 1:throw new Error(e.SIGN);case 2:throw new Error(e.IMPOSSIBLE_CASE)}},ecdsaVerify(r,o,a){switch(t(\"signature\",r,64),t(\"message\",o,32),t(\"public key\",a,[33,65]),i.ecdsaVerify(r,o,a)){case 0:return!0;case 3:return!1;case 1:throw new Error(e.SIG_PARSE);case 2:throw new Error(e.PUBKEY_PARSE)}},ecdsaRecover(c,s,E,u=!0,w){switch(t(\"signature\",c,64),r(\"Number\"===n(s)&&s>=0&&s<=3,\"Expected recovery id to be a Number within interval [0, 3]\"),t(\"message\",E,32),o(u),w=a(w,u?33:65),i.ecdsaRecover(w,c,s,E)){case 0:return w;case 1:throw new Error(e.SIG_PARSE);case 2:throw new Error(e.RECOVER);case 3:throw new Error(e.IMPOSSIBLE_CASE)}},ecdh(o,c,s={},E){switch(t(\"public key\",o,[33,65]),t(\"private key\",c,32),r(\"Object\"===n(s),\"Expected options to be an Object\"),void 0!==s.data&&t(\"options.data\",s.data),void 0!==s.hashfn?(r(\"Function\"===n(s.hashfn),\"Expected options.hashfn to be a Function\"),void 0!==s.xbuf&&t(\"options.xbuf\",s.xbuf,32),void 0!==s.ybuf&&t(\"options.ybuf\",s.ybuf,32),t(\"output\",E)):E=a(E,32),i.ecdh(E,o,c,s.data,s.hashfn,s.xbuf,s.ybuf)){case 0:return E;case 1:throw new Error(e.PUBKEY_PARSE);case 2:throw new Error(e.ECDH)}}}));"},"sourceMaps":null,"error":null,"hash":"a774126ce8091bc75c8800ba35ebce34","cacheData":{"env":{}}}